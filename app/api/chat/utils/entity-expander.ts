import { OpenAI } from 'openai';

function getOpenAIClient() {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    throw new Error('OPENAI_API_KEY environment variable is required');
  }
  return new OpenAI({ apiKey });
}

export interface ExpandedTerms {
  original: string;
  expansions: string[];
  related: string[];
  synonyms: string[];
}

export class EntityExpander {
  // Cache AI-generated expansions to avoid repeated API calls
  private expansionCache = new Map<string, string[]>();

  // Removed AI expansion method - using pattern-based only

  // Basic fallback expansion using patterns only
  private basicPatternExpansion(term: string): string[] {
    const expansions = new Set<string>();
    const lowerTerm = term.toLowerCase();

    // Handle common patterns
    if (lowerTerm.includes('-')) {
      expansions.add(lowerTerm.replace(/-/g, ' '));
      expansions.add(lowerTerm.replace(/-/g, ''));
    }
    if (lowerTerm.includes(' ')) {
      expansions.add(lowerTerm.replace(/ /g, '-'));
      expansions.add(lowerTerm.replace(/ /g, ''));
    }

    return Array.from(expansions);
  }
  // All expansions now handled by AI

  async expandTerm(term: string): Promise<ExpandedTerms> {
    const lowerTerm = term.toLowerCase();

    // Use fast pattern-based expansion instead of AI
    const expansions = this.basicPatternExpansion(lowerTerm);
    const related: string[] = [];
    const synonyms: string[] = [];

    // Add common variations
    if (lowerTerm === 'ai') {
      related.push('ml', 'machine learning', 'artificial intelligence');
    } else if (lowerTerm === 'ml') {
      related.push('ai', 'machine learning');
    } else if (lowerTerm.includes('develop')) {
      synonyms.push('engineer', 'build', 'create');
    }

    return {
      original: term,
      expansions,
      related,
      synonyms,
    };
  }

  async expandAllTerms(terms: string[]): Promise<ExpandedTerms[]> {
    return Promise.all(terms.map(term => this.expandTerm(term)));
  }

  async getAllSearchTerms(term: string): Promise<string[]> {
    const expanded = await this.expandTerm(term);
    const allTerms = new Set([
      expanded.original,
      ...expanded.expansions,
      ...expanded.related,
      ...expanded.synonyms,
    ]);
    return Array.from(allTerms);
  }

  // Synonyms now generated by AI in expandTerm method

  // Fast query expansion without AI
  async expandQueryContext(query: string): Promise<string[]> {
    // Simple word extraction for speed
    const words = query.toLowerCase().split(/\s+/).filter(word => word.length > 2);
    const expanded = new Set<string>();

    // Add basic variations
    words.forEach(word => {
      expanded.add(word);
      // Handle common patterns
      if (word === 'ai') {
        expanded.add('artificial');
        expanded.add('intelligence');
      } else if (word.endsWith('ing')) {
        expanded.add(word.slice(0, -3)); // Remove -ing
      } else if (word.endsWith('ed')) {
        expanded.add(word.slice(0, -2)); // Remove -ed
      }
    });

    return Array.from(expanded);
  }
}